import de.undercouch.gradle.tasks.download.Download

plugins {
    // https://plugins.gradle.org/plugin/com.gradleup.shadow
    id 'com.gradleup.shadow' version '8.3.8'
    // https://plugins.gradle.org/plugin/de.undercouch.download
    id 'de.undercouch.download' version '5.6.0'
    id 'java'
    // https://github.com/tbroyer/gradle-errorprone-plugin
    id 'net.ltgt.errorprone' version '4.3.0'
    // https://docs.gradle.org/current/userguide/eclipse_plugin.html
    id 'eclipse'
    // To show task list as a tree, run: ./gradlew <taskname> taskTree
    id 'com.dorongold.task-tree' version '4.0.1'
    // needed for formatting Gradle files
    id 'groovy'
    // Code formatting; defines targets "spotlessApply" and "spotlessCheck".
    // https://github.com/diffplug/spotless/tags ; see tags starting "gradle/"
    // Only works on JDK 11+ (even including the plugin crashes Gradle on JDK 8).
    id 'com.diffplug.spotless' version '7.2.1'
}

// There is another `repositories { ... }` block below; if you change this one, change that one as well.
repositories {
    maven { url = 'https://central.sonatype.com/repository/maven-snapshots/'}
    mavenCentral()
}

def majorVersionToInt(majorVersionString) {
    // ^(\d+) matches the first digit(s) at the start of the string.
    def m = majorVersionString =~ /^(\d+)/
    // If a match is found, use the whole match group [0][0] (the first digit(s)). Otherwise, use the original string.
    // m[0] is the list of match groups and m[0][0] is the whole match.
    // For example, for input "17", m[0] is ["17", "17"], and m[0][0] is "17".
    majorVersionString = m ? m[0][0] : majorVersionString
    return Integer.valueOf(majorVersionString)
}

ext {
    // Whether to use EISOP formatting.
    // Can also be achieved by having a project property with the same name.
    eisopFormatting = true || project.hasProperty('eisopFormatting')

    parentDir = file("${rootDir}/../").absolutePath

    // The int corresponding to the major version of the current JVM.
    currentRuntimeJavaVersion = majorVersionToInt(JavaVersion.current().getMajorVersion())

    String useJdkVersionProp = project.getProperties().get('useJdkVersion')
    if (useJdkVersionProp == null) {
        // If the property is not given, use the same version as the runtime.
        useJdkVersionInt = currentRuntimeJavaVersion
    } else {
        useJdkVersionInt = majorVersionToInt(useJdkVersionProp)
    }

    // On a Java 8 JVM, use error-prone javac and source/target 8.
    // On a Java 9+ JVM, use the host javac, default source/target, and required module flags.
    isJava8 = (useJdkVersionInt == 8)

    // As of 2025-04-28 (Lombok 1.18.38), delombok supports JDK 24-ea but not JDK 24 proper; see https://projectlombok.org/changelog .
    skipDelombok = (useJdkVersionInt >= 24)

    // NO-AFU - keep these variables live so tasks in checker/build.gradle configure without issue.
    annotationTools = "${parentDir}/annotation-tools"
    afu = "${annotationTools}/annotation-file-utilities"

    jtregHome = "${parentDir}/jtreg"
    gitScriptsHome = "${project(':checker').projectDir}/bin-devel/.git-scripts"
    plumeScriptsHome = "${project(':checker').projectDir}/bin-devel/.plume-scripts"
    htmlToolsHome = "${project(':checker').projectDir}/bin-devel/.html-tools"
    doLikeJavacHome = "${project(':checker').projectDir}/bin/.do-like-javac"
    templateforaCheckerDir = "${parentDir}/templatefora-checker"
    demosDir = "${parentDir}/checker-framework.demos"

    javadocMemberLevel = JavadocMemberLevel.PROTECTED

    // The local git repository, typically in the .git directory, but not for worktrees.
    // This value is always overwritten, but Gradle needs the variable to be initialized.
    localRepo = '.git'

    versions = [
        autoValue       : '1.11.0',
        // https://mvnrepository.com/artifact/com.google.errorprone/error_prone_core
        // If you update this:
        //  * Temporarily comment out "-Werror" elsewhere in this file
        //  * Repeatedly run `./gradlew clean compileJava` and fix all errors
        //  * Uncomment "-Werror"
        errorprone      : '2.40.0',
        // NOTE: Google Java Format requires JDK 17 or higher as of version 1.25.0.
        googleJavaFormat : '1.25.2',
        hashmapUtil     : '0.0.1',
        junit           : '4.13.2',
        lombok          : '1.18.38',
        // plume-util includes a version of reflection-util. When updating ensure the versions are consistent.
        plumeUtil       : '1.11.0',
        reflectionUtil  : '1.1.5',
    ]
}

// Enable exec/javaexec
interface InjectedExecOps {
    @Inject
    ExecOperations getExecOps()
}

// Keep in sync with check in
// framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java .
switch (JavaVersion.current()) {
    case JavaVersion.VERSION_1_8:
    case JavaVersion.VERSION_11:
    case JavaVersion.VERSION_17:
    case JavaVersion.VERSION_21:
        break; // Supported versions
    default:
        logger.info('The Checker Framework has only been tested with JDK 8, 11, 17, and 21.' +
        ' You are using JDK ' + JavaVersion.current().majorVersion + '.');
        break;
}

task setLocalRepo(type:Exec) {
    commandLine 'git', 'worktree', 'list'
    standardOutput = new ByteArrayOutputStream()
    doLast {
        String worktreeList = standardOutput.toString()
        localRepo = worktreeList.substring(0, worktreeList.indexOf(' ')) + '/.git'
    }
}

// No group so it does not show up in the output of `gradlew tasks`
task installGitHooks(type: Copy, dependsOn: 'setLocalRepo') {
    description = 'Copies git hooks to .git directory'
    from files('checker/bin-devel/git.post-merge', 'checker/bin-devel/git.pre-commit')
    rename('git\\.(.*)', '$1')
    into localRepo + '/hooks'
}

apply plugin: 'com.diffplug.spotless'
spotless {
    // Resolve the Spotless plugin dependencies from the buildscript repositories rather than the
    // project repositories.  That way the spotless plugin does not use the locally built version of
    // checker-qual as a dependency. Without this, errors like the follow are issued when running
    // a spotless task without a locally-built version of checker-qual.jar:
    // Could not determine the dependencies of task ':checker-qual:spotlessCheck'.
    //  > Could not create task ':checker-qual:spotlessJavaCheck'.
    //     > Could not create task ':checker-qual:spotlessJava'.
    //        > File signature can only be created for existing regular files, given:
    //          .../checker-framework/checker-qual/build/libs/checker-qual-3.25.1-SNAPSHOT.jar
    predeclareDepsFromBuildscript()
}

spotlessPredeclare {
    // Put all the formatters that have dependencies here.  Without this, errors like the following
    // will happen:
    // Could not determine the dependencies of task ':spotlessCheck'.
    //  > Could not create task ':spotlessJavaCheck'.
    //     > Could not create task ':spotlessJava'.
    //        > Add a step with [com.google.googlejavaformat:google-java-format:1.15.0] into the `spotlessPredeclare` block in the root project.
    java {
        googleJavaFormat(versions.googleJavaFormat)
    }
    groovyGradle {
        greclipse()
    }
    groovy {
        greclipse()
    }
}

allprojects { currentProj ->
    // Increment the minor version (second number) rather than just the patch
    // level (third number) if:
    //   * any new checkers have been added, or
    //   * backward-incompatible changes have been made to APIs or elsewhere.
    // To make a snapshot release, version should end in "-SNAPSHOT", then: ./gradlew publish
    version = '3.49.5-eisop1-SNAPSHOT'

    apply plugin: 'java'
    apply plugin: 'eclipse'
    apply plugin: 'com.gradleup.shadow'
    apply plugin: 'de.undercouch.download'
    apply plugin: 'net.ltgt.errorprone'

    group = 'io.github.eisop'

    // Keep in sync with "repositories { ... }" block above.
    repositories {
        maven { url = 'https://central.sonatype.com/repository/maven-snapshots/'}
        mavenCentral()
    }

    configurations {
        // This is required to run the Checker Framework on JDK 8.
        javacJar

        // Holds the combined classpath of all subprojects including the subprojects themselves.
        allProjects

        // Exclude checker-qual dependency added by Error Prone to avoid a circular dependency.
        annotationProcessor.exclude group:'org.checkerframework', module:'checker-qual'

        // This is to be used to add errorprone to the processorpath of the compile task.  The errorprone
        // configuration can't be used directly because it is marked unresolvable by the errorprone plugin.
        errorProneAnnotationProcessor.extendsFrom(errorprone)
    }

    dependencies {
        // Always include Error Prone, but it will not always be enabled.
        errorprone group: 'com.google.errorprone', name: 'error_prone_core', version: versions.errorprone
        // Always define javacJar, not just when `isJava8` is true, because we redistribute it in checker/build.gradle.
        javacJar group: 'com.google.errorprone', name: 'javac', version: "9+181-r4173-1"

        allProjects subprojects
    }

    eclipse.classpath {
        defaultOutputDir = file("build/default")
        file.whenMerged { cp ->
            cp.entries.forEach { cpe ->
                if (cpe instanceof org.gradle.plugins.ide.eclipse.model.SourceFolder) {
                    cpe.output = cpe.output.replace "bin/", "build/classes/java/"
                }
                if (cpe instanceof org.gradle.plugins.ide.eclipse.model.Output) {
                    cpe.path = cpe.path.replace "bin/", "build/"
                }
            }
        }
    }

    ext {
        // A list of add-export and add-open arguments to be used when running the Checker Framework.
        // Keep this list in sync with the lists in CheckerMain#getExecArguments,
        // the sections with labels "javac-jdk11-non-modularized", "maven", and "sbt" in the manual
        // and in the checker-framework-gradle-plugin, CheckerFrameworkPlugin#applyToProject
        compilerArgsForRunningCF = [
            // These are required in Java 16+ because the --illegal-access option is set to deny
            // by default.  None of these packages are accessed via reflection, so the module
            // only needs to be exported, but not opened.
            '--add-exports',
            'jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',
            '--add-exports',
            'jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED',
            '--add-exports',
            'jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED',
            '--add-exports',
            'jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED',
            '--add-exports',
            'jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED',
            '--add-exports',
            'jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED',
            '--add-exports',
            'jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',
            '--add-exports',
            'jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED',
            // Required because the Checker Framework reflectively accesses private members in com.sun.tools.javac.comp.
            '--add-opens',
            'jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED',
        ]
    }

    apply plugin: 'com.diffplug.spotless'
    // patterns of files to skip for individual sub-projects
    def perProjectDoNotFormat = [
        'checker': [
            'bin/.do-like-javac/**',
            'bin-devel/.git-scripts/**',
            'bin-devel/.html-tools/**',
            'bin-devel/.plume-scripts/**',
            'dist/**',
            'tests/ainfer-*/annotated/**',
            'tests/build/**',
            'tests/calledmethods-delomboked/**',
            'tests/nullness-javac-errors/**',
        ],
        'dataflow': ['manual/examples/**'],
        'docs': [
            'examples/BazelExample/bazel-BazelExample/**',
            'examples/lombok/build/**'
        ],
        'framework': [
            'tests/build/**',
            'tests/returnsreceiverdelomboked/**',
        ],
    ]
    spotless {
        // If you add any formatters to this block that require dependencies, then you must also
        // add them to spotlessPredeclare block.

        // Never format files under build/ directory.
        def doNotFormat = ['build/**']
        if (currentProj != project.rootProject) {
            if (perProjectDoNotFormat.containsKey(currentProj.name)) {
                doNotFormat += perProjectDoNotFormat[currentProj.name]
            }
            // if (currentRuntimeJavaVersion < 14) {
            doNotFormat += ['**/*record*/']
            // if (currentRuntimeJavaVersion < 16) {
            // TODO: directories should be renamed `-switchexpr` or some such,
            // as they  only contain examples for switch expressions, which were
            // added in Java 14, not Java 17.
            doNotFormat += ['**/java17/']
            // if (currentRuntimeJavaVersion < 21) {
            doNotFormat += ['tests/**/java21/']
            // TODO: run Gradle on a JDK between 21 and 24.
            if (currentRuntimeJavaVersion < 22) {
                doNotFormat += ['tests/**/java22/']
            }
        }

        format 'misc', {
            // define the files to apply `misc` to
            target '*.md', '*.tex', '.gitignore'
            targetExclude doNotFormat
            // define the steps to apply to those files
            leadingTabsToSpaces(2)
            trimTrailingWhitespace()
            // endWithNewline() // Don't want to end empty files with a newline
        }

        java {
            if (currentProj != currentProj.rootProject) {
                // not the root project; format all .java and .ajava files in the sub-project
                target '**/*.java', '**/*.ajava'
            }
            targetExclude doNotFormat

            if (eisopFormatting) {
                googleJavaFormat(versions.googleJavaFormat).aosp()
                importOrder('com', 'jdk', 'lib', 'lombok', 'org', 'java', 'javax')
            } else {
                googleJavaFormat(versions.googleJavaFormat) // the formatter to apply to Java files
            }
            formatAnnotations().addTypeAnnotation("PolyInitialized").addTypeAnnotation("PolyVP").addTypeAnnotation("ReceiverDependentQual")
        }

        java {
            if (currentProj != currentProj.rootProject) {
                // not the root project; format all .java files in the sub-project src folders
                target 'src/**/*.java'
            }
            targetExclude doNotFormat

            // This really just removes the wildcard imports - they are not expanded.
            // That is fine for src files, which should then be manually fixed.
            // There are currently many tests with wildcard imports, so do not enable this for tests.
            removeWildcardImports()
        }

        // Only define a groovyGradle task on the root project, for simplicity in setting the target pattern
        if (currentProj == currentProj.rootProject) {
            groovyGradle {
                target '**/*.gradle'
                targetExclude doNotFormat
                greclipse()  // which formatter Spotless should use to format .gradle files.
                if (eisopFormatting) {
                    leadingTabsToSpaces(4)
                } else {
                    leadingTabsToSpaces(2)
                }
                trimTrailingWhitespace()
                // endWithNewline() // Don't want to end empty files with a newline
            }

            groovy {
                target 'buildSrc/**/*.groovy'
                importOrder()

                // removes semicolons at the end of lines
                removeSemicolons()
                greclipse()
                leadingTabsToSpaces(2)
                trimTrailingWhitespace()
            }

            format 'make', {
                // define the files to apply `make` to
                target 'Makefile'
                targetExclude doNotFormat
                // define the steps to apply to those files
                trimTrailingWhitespace()
                endWithNewline()
            }

            // Don't do this, because it does not respect "ignore=true" in .editorconfig nor `doNotFormat` here.
            // shell {
            //   targetExclude doNotFormat
            //   shfmt() // configuration is in .editorconfig
            // }
        }

        // a useful task for debugging; prints exactly which files are getting formatted by spotless
        tasks.register('printSpotlessTaskInputs') {
            doLast {
                project.tasks.forEach { task ->
                    if (task.name.contains('spotless')) {
                        println "Inputs for task '${task.name}':"

                        task.inputs.files.each { inputFile ->
                            println "  Input: $inputFile"
                        }
                    }
                }
            }
        }
    }

    test {
        minHeapSize = "256m" // initial heap size
        maxHeapSize = "4g" // maximum heap size
    }

    // After all the tasks have been created, modify some of them.
    afterEvaluate {
        configurations {
            checkerFatJar {
                canBeConsumed = false
                canBeResolved = true
            }
        }

        dependencies {
            checkerFatJar(project(path: ':checker', configuration: 'fatJar'))
        }

        boolean useToolchains = (currentRuntimeJavaVersion != useJdkVersionInt)
        if (useToolchains) {
            // This uses the requested Java toolchain.
            // On CI, gradle always runs with JDK 21 and different versions are selected as toolchains.
            // CI test test-cftests-junit-jdk21 runs the JUnit tests on the different JDK versions,
            // to ensure there is no version mismatch between compiled-against javac APIs and runtime APIs.
            //   https://docs.gradle.org/current/userguide/toolchains.html
            java {
                toolchain {
                    languageVersion = JavaLanguageVersion.of(useJdkVersionInt)
                }
            }

            // JavaExec does not automatically inherit the toolchain JDK (!).
            tasks.withType(JavaExec).configureEach {
                javaLauncher = javaToolchains.launcherFor {
                    languageVersion = JavaLanguageVersion.of(useJdkVersionInt)
                }
            }
            // JavaCompile also seems to need an extra push...
            tasks.withType(JavaCompile).configureEach {
                javaCompiler = javaToolchains.compilerFor {
                    languageVersion = JavaLanguageVersion.of(useJdkVersionInt)
                }
            }
        }

        // Add the fat checker.jar to the classpath of every Javadoc task. This allows Javadoc in
        // any module to reference classes in any other module.
        // Also, build and use ManualTaglet as a taglet.
        tasks.withType(Javadoc) {
            // Similar test in framework-test/build.gradle
            def tagletVersion = isJava8 ? 'tagletJdk8' : 'taglet'

            dependsOn(':checker:shadowJar')
            dependsOn(":framework-test:${tagletVersion}Classes")

            doFirst {
                options.encoding = 'UTF-8'
                if (!name.equals('javadocDoclintAll')) {
                    options.memberLevel = javadocMemberLevel
                }
                classpath += configurations.getByName('checkerFatJar').asFileTree
                if (isJava8) {
                    classpath += configurations.javacJar
                }
                options.taglets 'org.checkerframework.taglet.ManualTaglet'
                options.tagletPath(project(':framework-test').sourceSets."${tagletVersion}".output.classesDirs.getFiles() as File[])

                // This file is looked for by Javadoc.
                file("${destinationDir}/resources/fonts/").mkdirs()
                ant.touch(file: "${destinationDir}/resources/fonts/dejavu.css")

                if (!isJava8) {
                    options.addBooleanOption('-add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED', true)
                    options.addBooleanOption('-add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED', true)
                    options.addBooleanOption('-add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED', true)
                    options.addBooleanOption('-add-exports=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED', true)
                    options.addBooleanOption('-add-exports=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED', true)
                    options.addBooleanOption('-add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED', true)
                    options.addBooleanOption('-add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED', true)
                    options.addBooleanOption('-add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED', true)
                    options.addBooleanOption('-add-exports=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED', true)
                }

                // "-Xwerror" requires Javadoc everywhere.  Currently, CI jobs require Javadoc only
                // on changed lines.  Enable -Xwerror in the future when all Javadoc exists.
                // options.addBooleanOption('Xwerror', true)
                options.addStringOption('Xmaxwarns', '99999')
            }
        }

        // Add standard javac options
        tasks.withType(JavaCompile) { compilationTask ->
            dependsOn(':installGitHooks')

            // Sorting is commented out because it disables incremental compilation.
            // Uncomment when needed.
            // // Put source files in deterministic order, for debugging.
            // compilationTask.source = compilationTask.source.sort()

            // This test is for whether the Checker Framework supports (runs under) Java 8.
            // Currently, the Checker Framework does support Java 8.
            if (true) {
                // Using `options.release.set(8)` here leads to compilation
                // errors such as "package com.sun.source.tree does not exist".
                sourceCompatibility = 8
                targetCompatibility = 8
                // Because the target is 8, all of the public compiler classes are accessible, so
                // --add-exports are not required (nor are they allowed with target 8). See
                // https://openjdk.org/jeps/247 for details on compiling for older versions.
            } else {
                // This makes the class files Java 11, and then the Checker Framework would not run under Java 8.
                options.release.set(11)
                options.compilerArgs += [
                    '--add-exports',
                    'jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',
                    '--add-exports',
                    'jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED',
                    '--add-exports',
                    'jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED',
                    '--add-exports',
                    'jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED',
                    '--add-exports',
                    'jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED',
                    '--add-exports',
                    'jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED',
                    '--add-exports',
                    'jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED',
                    '--add-exports',
                    'jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',
                    '--add-exports',
                    'jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED',
                ]
                // This is equivalent to writing "exports jdk.compiler/... to ALL-UNNAMED" in the
                // module-info.java of jdk.compiler, so corresponding --add-opens are only required for
                // reflective access to private members.
                //
                // From https://openjdk.org/jeps/261, Section titled: "Breaking encapsulation"
                // "The effect of each instance [of --add-exports] is to add a qualified export of the
                // named package from the source module to the target module. This is, essentially, a
                // command-line form of an exports clause in a module declaration[...].
                // [...]
                // The --add-exports option enables access to the public types of a specified package.
                // It is sometimes necessary to go further and enable access to all non-public elements
                // via the setAccessible method of the core reflection API. The --add-opens option can
                // be used, at run time, to do this."
            }

            options.failOnError = true
            options.deprecation = true
            // -options: To not get a warning about missing bootstrap classpath (when using Java 9 and `-source 8`).
            // -fallthrough: Don't check fallthroughs.  Instead, use Error Prone.  Its
            //   warnings are suppressible with a "// fall through" comment.
            // -classfile: classgraph jar file and https://bugs.openjdk.org/browse/JDK-8190452
            options.compilerArgs += [
                '-g',
                '-Werror',
                '-Xlint:-options,-fallthrough,-classfile',
                '-Xlint',
            ]

            options.encoding = 'UTF-8'
            options.fork = true
            if (isJava8) {
                options.forkOptions.jvmArgs += [
                    "-Xbootclasspath/p:${configurations.javacJar.asPath}".toString()
                ]
            }

            if ((compilationTask.name.equals('compileJava') || compilationTask.name.equals('compileTestJava'))
                    // Error Prone depends on checker-qual.jar, so don't run it on that project to avoid a circular dependency.
                    && !project.name.startsWith('checker-qual')) {
                // Error Prone must be available in the annotation processor path
                options.annotationProcessorPath = configurations.errorProneAnnotationProcessor
                // Enable Error Prone
                options.errorprone.enabled = (useJdkVersionInt >= 17) && (useJdkVersionInt <= 24)
                options.errorprone.disableWarningsInGeneratedCode = true
                options.errorprone.errorproneArgs = [
                    // Many compiler classes are interned.
                    '-Xep:ReferenceEquality:OFF',
                    // Not useful to suggest Splitter; maybe clean up.
                    '-Xep:StringSplitter:OFF',
                    // Too broad, rejects seemingly-correct code.
                    '-Xep:EqualsGetClass:OFF',
                    // Not a real problem
                    '-Xep:MixedMutabilityReturnType:OFF',
                    // Don't want to add a dependency to ErrorProne.
                    '-Xep:AnnotateFormatMethod:OFF',
                    // Warns for every use of "@checker_framework.manual"
                    '-Xep:InvalidBlockTag:OFF',
                    // Recommends writing @InlineMe which is an Error-Prone-specific annotation
                    '-Xep:InlineMeSuggester:OFF',
                    // Recommends writing @CanIgnoreReturnValue which is an Error-Prone-specific annotation.
                    // It would be great if Error Prone recognized the @This annotation.
                    '-Xep:CanIgnoreReturnValueSuggester:OFF',
                    // Should be turned off when using the Checker Framework.
                    '-Xep:ExtendsObject:OFF',
                    // For Visitors it is convenient to just pass a Void parameter.
                    '-Xep:VoidUsed:OFF',
                    // -Werror halts the build if Error Prone issues a warning, which ensures that
                    // the errors get fixed.  On the downside, Error Prone (or maybe the compiler?)
                    // stops as soon as it issues one warning, rather than outputting them all.
                    // https://github.com/google/error-prone/issues/436
                    '-Werror',
                ]

                if (compilationTask.name.equals('compileTestJava')) {
                    options.errorprone.errorproneArgs.addAll([
                        // Some Value Checker tests use int literals intentionally(?).
                        '-Xep:IntLiteralCast:OFF'
                    ])
                }

                if (!isJava8) {
                    // Options needed for Error Prone on Java 16+, but don't hurt on Java 9+
                    options.forkOptions.jvmArgs += [
                        '--add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',
                        '--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED',
                        '--add-exports=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED',
                        '--add-exports=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED',
                        '--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED',
                        '--add-exports=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED',
                        '--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',
                        '--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED',
                        '--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED',
                        '--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED',
                    ]
                }
            } else {
                options.errorprone.enabled = false
            }
        }
    } // end afterEvaluate
} // end allProjects

task version(group: 'Documentation') {
    description = 'Print Checker Framework version'
    doLast {
        println version
    }
}

/**
 * Creates a task that runs the checker on the main source set of each subproject. The task is named
 * "check${taskName}", for example "checkPurity" or "checkNullness".
 *
 * @param projectName name of the project
 * @param taskName short name (often the checker name) to use as part of the task name
 * @param checker fully qualified name of the checker to run
 * @param args list of arguments to pass to the checker
 */
def createCheckTypeTask(projectName, taskName, checker, args = []) {
    project("${projectName}").tasks.create(name: "check${taskName}", type: JavaCompile, dependsOn: ':checker:shadowJar') {
        description = "Run the ${taskName} Checker on the main sources."
        group = 'Verification'
        // Always run the task.
        outputs.upToDateWhen { false }
        source = project("${projectName}").sourceSets.main.java
        classpath = files(project("${projectName}").compileJava.classpath,project(':checker-qual').sourceSets.main.output)
        destinationDirectory = file("${buildDir}")

        options.annotationProcessorPath = files(project(':checker').tasks.shadowJar.archiveFile)
        options.compilerArgs += [
            '-processor',
            "${checker}",
            '-proc:only',
            '-Xlint:-processing',
            '-Xmaxerrs',
            '10000',
            '-Xmaxwarns',
            '10000',
            '-ArequirePrefixInWarningSuppressions',
            '-AwarnUnneededSuppressions',
            '-AwarnRedundantAnnotations',
            '-AnoJreVersionCheck',
        ]
        options.compilerArgs += args

        // TODO: the options below should be inherited from JavaCompile. Why does this need to be repeated?
        if (isJava8) {
            options.compilerArgs += [
                '-source',
                '8',
                '-target',
                '8'
            ]
        } else {
            options.fork = true
            options.forkOptions.jvmArgs += compilerArgsForRunningCF
        }
    }
}

task htmlValidate(type: Exec, group: 'Format') {
    description = 'Validate that HTML files are well-formed'
    // This is the Nu Html Checker (v.Nu): https://github.com/validator/validator
    executable 'html5validator'
    args = [
        '--ignore',
        '/api/',
        '/build/',
        '/docs/manual/manual.html',
        '/docs/manual/plume-bib/docs/index.html',
        '/checker/jdk/nullness/src/java/lang/ref/package.html'
    ]
}

def javadocDirs = [
    project(':checker').sourceSets.main.allJava,
    project(':checker').sourceSets.test.allJava,
    project(':checker-qual').sourceSets.main.allJava,
    project(':checker-util').sourceSets.main.allJava,
    project(':checker-util').sourceSets.test.allJava,
    project(':dataflow').sourceSets.main.allJava,
    project(':dataflow').sourceSets.test.allJava,
    project(':framework').sourceSets.main.allJava,
    project(':framework').sourceSets.test.allJava,
    project(':framework-test').sourceSets.main.allJava,
    project(':framework-test').sourceSets.test.allJava,
    project(':javacutil').sourceSets.main.allJava
]

def requireJavadocDirs = javadocDirs

project(':checker').afterEvaluate {
    requireJavadocDirs += project(':checker').sourceSets.testannotations.allJava
}

project(':framework').afterEvaluate {
    requireJavadocDirs += project(':framework').sourceSets.testannotations.allJava
}

task addFavicon(type: Exec) {
    dependsOn 'getHtmlTools'
    dependsOn 'allJavadoc'
    workingDir "${rootDir}/docs/api"
    executable "${htmlToolsHome}/html-add-favicon"
    args += [
        '.',
        'favicon-checkerframework.png'
    ]
    doFirst {
        copy {
            from 'docs/logo/Checkmark/CFCheckmark_favicon.png'
            rename('CFCheckmark_favicon.png', 'favicon-checkerframework.png')
            into "${rootDir}/docs/api"
        }
    }
}

// `gradle allJavadoc` builds the Javadoc for all modules in `docs/api`.
//   This is what is published to checkerframework.org.
// `gradle javadoc` builds the Javadoc for each sub-project in <subproject>/build/docs/javadoc/ .
//   It's needed to create the Javadoc jars that we release in Maven Central.
// To make javadoc for only one subproject, run `./gradlew javadoc`
//   in the subproject or `./gradlew :checker:javadoc` at the top level.
task allJavadoc(type: Javadoc, group: 'Documentation') {
    description = 'Generates API documentation that includes all the modules.'
    dependsOn(':checker:shadowJar', 'getPlumeScripts')
    destinationDir = file("${rootDir}/docs/api")
    source javadocDirs

    doFirst {
        source(
                project(':framework-test').sourceSets."${isJava8 ? 'tagletJdk8' : 'taglet'}".allJava
                )
    }

    classpath = configurations.allProjects

    if (isJava8) {
        classpath += configurations.javacJar
    }

    // disable interpreting module-info.java files until all sub-modules support them
    modularity.inferModulePath = false

    finalizedBy 'addFavicon'
}

// See documentation for allJavadoc task.
javadoc.dependsOn(allJavadoc)

task cleanManual(type: Exec) {
    description = 'Clean the manual'
    commandLine 'make', '-C', 'docs/manual', 'clean'
}
clean.dependsOn(cleanManual)
clean {
    delete(file("${rootDir}/docs/api"))
}

configurations {
    requireJavadoc
}

dependencies {
    requireJavadoc 'org.plumelib:require-javadoc:2.0.0'
}

task requireJavadoc(type: JavaExec, group: 'Documentation') {
    description = 'Ensures that Javadoc documentation exists in source code.'
    mainClass = 'org.plumelib.javadoc.RequireJavadoc'
    classpath = configurations.requireJavadoc
    // Convert each srcDir to its absolute path and flatten the list
    args requireJavadocDirs.collect { it.srcDirs*.absolutePath }.flatten()
    jvmArgs += [
        '--add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED',
        '--add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED',
        '--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',
        '--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED',
        '--add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED',
        '--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED',
        '--add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',
        '--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED',
    ]
}


/**
 * Creates a task named taskName that runs javadoc with the -Xdoclint:all option.
 *
 * @param taskName the name of the task to create
 * @param taskDescription description of the task
 * @param memberLevel the JavadocMemberLevel to use
 * @return the new task
 */
def createJavadocTask(taskName, taskDescription, memberLevel) {
    tasks.create(name: taskName, type: Javadoc) {
        description = taskDescription
        destinationDir = file("${rootDir}/docs/tmpapi")
        destinationDir.mkdirs()
        subprojects.forEach {
            if (!it.name.startsWith('checker-qual-android')) {
                source += it.sourceSets.main.allJava
            }
        }

        classpath = configurations.allProjects
        // disable interpreting module-info.java files until all sub-modules support them
        modularity.inferModulePath = false

        destinationDir.deleteDir()
        options.memberLevel = memberLevel
        options.addBooleanOption('Xdoclint:all', true)
        options.addStringOption('Xmaxwarns', '99999')

        // options.addStringOption('skip', 'ClassNotToCheck|OtherClass')
    }
}

createJavadocTask('javadocDoclintAll', 'Runs javadoc with -Xdoclint:all option.', JavadocMemberLevel.PRIVATE)

task manual(type: Exec, group: 'Documentation') {
    description = 'Build the manual'
    commandLine 'make', '-C', 'docs/manual', 'all'
}

// No group so it does not show up in the output of `gradlew tasks`
task downloadJtreg(type: Download) {
    description = 'Downloads and unpacks jtreg.'
    onlyIf { !(new File("${jtregHome}/lib/jtreg.jar").exists()) }
    // src 'https://ci.adoptopenjdk.net/view/Dependencies/job/jtreg/lastSuccessfulBuild/artifact/jtreg-4.2.0-tip.tar.gz'
    // If ci.adoptopenjdk.net is down, use this copy.
    // src 'https://checkerframework.org/jtreg-4.2.0-tip.tar.gz'
    // dest new File(buildDir, 'jtreg-4.2.0-tip.tar.gz')
    // src 'https://builds.shipilev.net/jtreg/jtreg4.2-b16.zip'
    src 'https://builds.shipilev.net/jtreg/jtreg-7.5+1.zip'
    dest new File(buildDir, 'jtreg.zip')
    overwrite true
    retries 3

    def injected = project.objects.newInstance(InjectedExecOps)

    doLast {
        copy {
            // Use 'tarTree' when downloading a .tar.gz file
            from zipTree(dest)
            into "${jtregHome}/.."
        }
        injected.execOps.exec {
            commandLine('chmod',  '+x', "${jtregHome}/bin/jtdiff", "${jtregHome}/bin/jtreg")
        }
    }
}

tasks.register('getGitScripts', CloneTask) {
    url.set('https://github.com/eisop-plume-lib/git-scripts.git')
    directory.set(file(gitScriptsHome))
    outputs.upToDateWhen { false }
}

tasks.register('getPlumeScripts', CloneTask) {
    url.set('https://github.com/eisop-plume-lib/plume-scripts.git')
    directory.set(file(plumeScriptsHome))
    outputs.upToDateWhen { false }
}

tasks.register('getHtmlTools', CloneTask) {
    url.set('https://github.com/plume-lib/html-tools.git')
    directory.set(file(htmlToolsHome))
    outputs.upToDateWhen { false }
}

tasks.register('getDoLikeJavac', CloneTask) {
    url.set('https://github.com/opprop/do-like-javac.git')
    directory.set(file(doLikeJavacHome))
    outputs.upToDateWhen { false }
}

tasks.register('getTemplateforaChecker', CloneTask) {
    url.set('https://github.com/eisop/templatefora-checker.git')
    directory.set(file(templateforaCheckerDir))
    outputs.upToDateWhen { false }
}

tasks.register('getDemos', CloneTask) {
    url.set('https://github.com/eisop/checker-framework.demos.git')
    directory.set(file(demosDir))
    outputs.upToDateWhen { false }
}

// No group so it does not show up in the output of `gradlew tasks`
task pythonIsInstalled(type: Exec) {
    description = 'Check that the python3 executable is installed.'
    executable = 'python3'
    args '--version'
}

task docTags(type: Exec, group: 'Emacs') {
    commandLine 'make', '-C', 'docs/manual', 'tags'
}

task tags(type: Exec, group: 'Emacs') {
    dependsOn docTags
    description = 'Create Emacs TAGS table'
    // running this task will also run the tags task in the subprojects, which is defined later in this file.
    commandLine 'etags', '-i', 'checker/TAGS', '-i', 'checker-qual/TAGS', '-i', 'checker-util/TAGS', '-i', 'dataflow/TAGS', '-i', 'framework/TAGS', '-i', 'framework-test/TAGS', '-i', 'javacutil/TAGS', '-i', 'docs/manual/TAGS'
}

subprojects {
    configurations {
        annotatedGuava
    }

    dependencies {
        // TODO: it's a bug that annotatedlib:guava requires the error_prone_annotations dependency.
        annotatedGuava "com.google.errorprone:error_prone_annotations:${versions.errorprone}"
        annotatedGuava ('org.checkerframework.annotatedlib:guava:33.1.0.2-jre') {
            // So long as Guava only uses annotations from checker-qual, excluding it should not cause problems.
            exclude group: 'org.checkerframework'
        }
    }

    shadowJar {
        // If you add an external dependency, then do the following:
        //  * On the master branch and on the modified branch, run:
        //    ./gradlew assembleForJavac && jar tf checker/dist/checker.jar | grep -v '^annotated-jdk/' | sort > checker-jar-contents.txt
        //  * Compare the files, and add relocate lines below.
        //  * Repeat until no new classes appear (all are under org/checkerframework/).

        // Note that string literals are also relocated. Therefore, when the original
        // names should be used, e.g. to load the original classes, one needs to work
        // around the relocation. When adding a new external dependency, make
        // sure no existing string literals are accidentally relocated.
        // For an example work-around see NullnessAnnotatedTypeFactory#NONNULL_ALIASES.

        // Relocate packages that might conflict with user's classpath.
        relocate 'com.github.javaparser', 'org.checkerframework.com.github.javaparser'
        relocate 'org.apache', 'org.checkerframework.org.apache'
        relocate 'org.relaxng', 'org.checkerframework.org.relaxng'
        relocate 'org.plumelib', 'org.checkerframework.org.plumelib'
        relocate 'org.codehaus', 'org.checkerframework.org.codehaus'
        relocate 'org.objectweb.asm', 'org.checkerframework.org.objectweb.asm'
        // Add the classgraph relocations if it is included in releases.
        // relocate 'io.github.classgraph', 'org.checkerframework.io.github.classgraph'
        // relocate 'nonapi.io.github.classgraph', 'org.checkerframework.nonapi.io.github.classgraph'
        // relocate 'sun', 'org.checkerframework.sun'
        relocate 'com.google', 'org.checkerframework.com.google'

        exclude '**/module-info.class'

        minimize()
    }

    if (!project.name.startsWith('checker-qual-android')) {
        task tags(type: Exec) {
            description = 'Create Emacs TAGS table'
            // `ctags -e -f TAGS` used to work in place of `etags`, but apparently no longer.
            commandLine 'bash', '-c', "find . \\( -name build -o -name jtreg -o -name tests \\) -prune -o -name '*.java' -print | sort-directory-order | xargs etags"
        }
    }

    java {
        withJavadocJar()
        withSourcesJar()
    }

    // Things in this block reference definitions in the subproject that do not exist,
    // until the project is evaluated.
    afterEvaluate {
        // Adds manifest to all Jar files
        tasks.withType(Jar) {
            includeEmptyDirs = false
            if (archiveFileName.get().startsWith('checker-qual') || archiveFileName.get().startsWith('checker-util')) {
                metaInf {
                    from './LICENSE.txt'
                }
            } else {
                metaInf {
                    from "${rootDir}/LICENSE.txt"
                }
            }
            manifest {
                attributes('Implementation-Version': "${project.version}")
                attributes('Implementation-URL': 'https://eisop.github.io/')
                if (! archiveFileName.get().endsWith('source.jar') && ! archiveFileName.get().startsWith('checker-qual')) {
                    attributes('Automatic-Module-Name': 'org.checkerframework.' + project.name.replaceAll('-', '.'))
                }
                if (archiveFileName.get().startsWith('checker-qual') || archiveFileName.get().startsWith('checker-util')) {
                    attributes('Bundle-License': 'MIT')
                } else {
                    attributes('Bundle-License': '(GPL-2.0-only WITH Classpath-exception-2.0)')
                }
            }
        }

        // Tasks such as `checkResourceLeak` to run various checkers on all the main source sets.
        // These pass and are run by the `typecheck` task.
        // When you add one here, also update a dependsOn item for the 'typecheck' task.
        createCheckTypeTask(project.name, 'Formatter',
                'org.checkerframework.checker.formatter.FormatterChecker')
        createCheckTypeTask(project.name, 'Interning',
                'org.checkerframework.checker.interning.InterningChecker',
                [
                    '-Astubs=javax-lang-model-element-name.astub'
                ])
        createCheckTypeTask(project.name, 'Optional',
                'org.checkerframework.checker.optional.OptionalChecker',
                [
                    // to avoid having to annotate JavaParser
                    '-AassumePureGetters',
                    '-AassumeAssertionsAreEnabled',
                ])
        createCheckTypeTask(project.name, 'Purity',
                'org.checkerframework.framework.util.PurityChecker')
        createCheckTypeTask(project.name, 'ResourceLeak',
                'org.checkerframework.checker.resourceleak.ResourceLeakChecker')
        createCheckTypeTask(project.name, 'Signature',
                'org.checkerframework.checker.signature.SignatureChecker')

        def isDataflow = project.name.is('dataflow')
        def isFramework = project.name.is('framework')
        def isChecker = project.name.is('checker')

        // The checkNullness task runs on all code, but it only *checks* the following code:
        //  * All files outside the 'framework' and 'checker' subprojects.
        //  * In the 'framework' and 'checker' subprojects, files with `@AnnotatedFor("nullness")`.
        if (isFramework || isChecker) {
            createCheckTypeTask(project.name, 'Nullness',
                    'org.checkerframework.checker.nullness.NullnessChecker',
                    [
                        '-AskipUses=com\\.sun\\.*',
                        // If a file does not contain @AnnotatedFor("nullness"), all its routines are assumed to return @Nullable.
                        '-AuseConservativeDefaultsForUncheckedCode=source',
                        '-AconservativeArgumentNullnessAfterInvocation=true',
                    ])
        } else {
            createCheckTypeTask(project.name, 'Nullness',
                    'org.checkerframework.checker.nullness.NullnessChecker',
                    [
                        '-AskipUses=com\\.sun\\.*',
                        '-AconservativeArgumentNullnessAfterInvocation=true'
                    ])
        }


        // Add jtregTests to framework and checker modules.
        // Jtreg only works on Java 11+.
        if (useJdkVersionInt >= 11 && (isFramework || isChecker)) {
            tasks.create(name: 'jtregTests', type: Exec, group: 'Verification') {
                description = 'Run the jtreg tests. Requires jtreg to be installed.'
                dependsOn(':downloadJtreg')
                dependsOn('compileJava')
                dependsOn('compileTestJava')
                dependsOn('shadowJar')

                String jtregOutput = "${buildDir}/jtreg"
                String name = 'all'
                String tests = '.'

                executable "${jtregHome}/bin/jtreg"
                args = [
                    "-dir:${projectDir}/jtreg",
                    "-workDir:${jtregOutput}/${name}/work",
                    "-reportDir:${jtregOutput}/${name}/report",
                    '-verbose:error,fail,nopass',
                    // Don't add debugging information
                    //  '-javacoptions:-g',
                    '-keywords:!ignore',
                    '-samevm',
                    "-javacoptions:-classpath ${tasks.shadowJar.archiveFile.get()}:${sourceSets.test.output.asPath}",
                    // Required for checker/jtreg/nullness/PersistUtil.java and other tests
                    "-vmoptions:-classpath ${tasks.shadowJar.archiveFile.get()}:${sourceSets.test.output.asPath}",
                ]
                args += [
                    // checker/jtreg/nullness/defaultsPersist/ReferenceInfoUtil.java
                    // uses the jdk.jdeps module.
                    '-javacoptions:--add-modules jdk.jdeps',
                    '-javacoptions:--add-exports=jdk.jdeps/com.sun.tools.classfile=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.jdeps/com.sun.tools.classfile=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',
                    '-vmoptions:--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED',
                ]
                if (isFramework) {
                    // Do not check for the annotated JDK
                    args += [
                        '-javacoptions:-ApermitMissingJdk'
                    ]
                } else if (isChecker) {
                    args += [
                        "-javacoptions:-classpath ${sourceSets.testannotations.output.asPath}",
                    ]
                }

                // Allow running on any JRE version.
                args += [
                    "-javacoptions:-AnoJreVersionCheck"
                ]

                // Location of jtreg tests
                args += "${tests}"
            }
        }

        // Create a task for each JUnit test class whose name is the same as the JUnit class name.
        // Regex [\\\\/] matches Unix and Windows directory separators.
        sourceSets.test.allJava.filter {it.path.matches('.*test[\\\\/]junit.*')}.forEach { file ->
            String junitClassName = file.name.replaceAll('.java', '')
            tasks.create(name: "${junitClassName}", type: Test) {
                description = "Run ${junitClassName} tests."
                include "**/${name}.class"
                testClassesDirs = testing.suites.test.sources.output.classesDirs
                classpath = testing.suites.test.sources.runtimeClasspath
            }
        }

        // Configure JUnit tests
        tasks.withType(Test) {
            if (isJava8) {
                jvmArgs "-Xbootclasspath/p:${configurations.javacJar.asPath}".toString()
            } else {
                jvmArgs += compilerArgsForRunningCF
            }

            // maxParallelForks controls the parallelism of a single Test
            // task. --parallel controls parallelism for the entire build.

            // Run tests in parallel, except on CI where it seems to lead to flaky failures.
            // The TF_BUILD environment variable is set to 'True' for jobs running on Azure Pipelines.
            if (!System.getenv('TF_BUILD')?.equals('True')) {
                // Not running under Azure Pipelines CI.

                maxParallelForks = Runtime.runtime.availableProcessors() ?: 1
            } else {
                // Running under Azure Pipelines CI.

                // Per Manu's comment above, on CI, parallelism seems to lead to flaky failures.
                maxParallelForks = 1

                // Fork the test to try to improve performance.
                // https://docs.gradle.org/current/userguide/performance.html#fork_tests_into_multiple_processes
                tasks.withType(Test).configureEach {
                    forkEvery = 25
                }
            }

            if (isChecker) {
                dependsOn('assembleForJavac')
            }

            if (project.hasProperty('emit.test.debug')) {
                systemProperties += ['emit.test.debug': 'true']
            }

            testLogging {
                showStandardStreams = true
                // Always run the tests
                outputs.upToDateWhen { false }

                // Show the found unexpected diagnostics and expected diagnostics not found.
                exceptionFormat = 'full'
                events 'failed'

                // Don't show the uninteresting stack traces from the exceptions.
                showStackTraces = false
            }

            // After each test, print a summary.
            afterSuite { desc, result ->
                if (desc.getClassName() != null) {
                    long mils = result.getEndTime() - result.getStartTime()
                    double seconds = mils / 1000.0

                    println "Testsuite: ${desc.getClassName()}\n" +
                            "Tests run: ${result.testCount}, " +
                            "Failures: ${result.failedTestCount}, " +
                            "Skipped: ${result.skippedTestCount}, " +
                            "Time elapsed: ${seconds} sec\n"
                }
            }
        }

        // Create a nonJunitTests task per project
        tasks.create(name: 'nonJunitTests', group: 'Verification') {
            description = 'Run all Checker Framework tests except for the JUnit tests and inference tests.'
            if (useJdkVersionInt >= 11 && (isFramework || isChecker)) {
                dependsOn('jtregTests')
            }
            if (isFramework) {
                dependsOn('loaderTests')
            }

            if (isChecker) {
                if (!isJava8) {
                    dependsOn('jtregJdk11Tests')
                }
                dependsOn('nullnessExtraTests', 'commandLineTests', 'tutorialTests')
            }

            if (isDataflow) {
                dependsOn('allDataflowTests')
            }
        }

        // Create an inferenceTests task per project
        tasks.create(name: 'inferenceTests', group: 'Verification') {
            description = 'Run inference tests.'
            if (isChecker) {
                // NO-AFU: Needs to depend on future AFU version of CF
                // dependsOn('inferenceTests-part1', 'inferenceTests-part1')
            }
        }
        tasks.create(name: 'inferenceTests-part1', group: 'Verification') {
            description = 'Run inference tests (part 1).'
            if (isChecker) {
                // NO-AFU: Needs to depend on future AFU version of CF
                // dependsOn('ainferTest', 'wpiManyTest')
            }
        }
        tasks.create(name: 'inferenceTests-part2', group: 'Verification') {
            description = 'Run inference tests (part 2).'
            if (isChecker) {
                // NO-AFU: Needs to depend on future AFU version of CF
                // dependsOn('wpiPlumeLibTest')
            }
        }

        // Create a typecheck task per project (dogfooding the Checker Framework on itself).
        // This isn't a test of the Checker Framework as the test and nonJunitTests tasks are.
        // Tasks such as 'checkInterning' are constructed by createCheckTypeTask.
        tasks.create(name: 'typecheck', group: 'Verification') {
            description = 'Run the Checker Framework on itself'
            dependsOn('typecheck-part1', 'typecheck-part2')
        }
        tasks.create(name: 'typecheck-part1', group: 'Verification') {
            description = 'Run the Checker Framework on itself (part 1)'
            dependsOn('checkFormatter', 'checkInterning', 'checkOptional', 'checkPurity')
        }
        tasks.create(name: 'typecheck-part2', group: 'Verification') {
            description = 'Run the Checker Framework on itself (part 2)'
            dependsOn('checkResourceLeak', 'checkSignature')
            if (isFramework || isChecker) {
                dependsOn('checkCompilerMessages')
            }
            dependsOn('checkNullness')
        }

        // Create an allTests task per project.
        // allTests = test + nonJunitTests + inferenceTests + typecheck
        tasks.create(name: 'allTests', group: 'Verification') {
            description = 'Run all Checker Framework tests'
            // The 'test' target is just the JUnit tests.
            dependsOn('test', 'nonJunitTests', 'inferenceTests', 'typecheck')
        }

        task javadocPrivate(dependsOn: javadoc) {
            doFirst {
                javadocMemberLevel = JavadocMemberLevel.PRIVATE
            }
            doLast {
                javadocMemberLevel = JavadocMemberLevel.PROTECTED
            }
        }
    }
}

// The `assembleForJavac` task is faster than the `assemble` task, if you only
// care about running `javac`.
// The assemble task also produces Javadoc jars, because its purpose is to build
// all artifacts produced by the Gradle project:
// https://docs.gradle.org/current/userguide/base_plugin.html#sec:base_tasks
assemble.dependsOn(':checker:assembleForJavac')

assemble.mustRunAfter(clean)

task buildAll(group: 'Build') {
    description = 'Build all jar files, including source and javadoc jars'
    dependsOn(allJavadoc)
    subprojects { Project subproject ->
        dependsOn("${subproject.name}:assemble")
        dependsOn("${subproject.name}:javadocJar")
        dependsOn("${subproject.name}:sourcesJar")
    }
    dependsOn('framework:allJavadocJar', 'framework:allSourcesJar', 'checker:allJavadocJar', 'checker:allSourcesJar', 'checker-qual:jar', 'checker-util:jar')
    dependsOn('checker:assembleForJavac')
}

task releaseBuild(group: 'Build') {
    description = 'Cleans, then builds everything required for a release'
    dependsOn(clean)
    dependsOn(buildAll)
}

// No group so it does not show up in the output of `gradlew tasks`
task releaseAndTest {
    description = 'Build everything required for a release and run allTests'
    dependsOn(releaseBuild)
    subprojects { Project subproject ->
        dependsOn("${subproject.name}:allTests")
    }
}

// Don't create an empty checker-framework-VERSION.jar
jar.onlyIf {false}

/**
 * Adds the shared pom information to the given publication.
 * @param publication the MavenPublication
 */
final sharedPublicationConfiguration(publication) {
    publication.pom {
        url = 'https://eisop.github.io/'
        developers {
            // These are the lead developers/maintainers, not all the developers or contributors.

            // For eisop, previously also typetools
            developer {
                id = 'wmdietl'
                name = 'Werner M. Dietl'
                email = 'wdietl@gmail.com'
                url = 'https://ece.uwaterloo.ca/~wdietl/'
                organization = 'University of Waterloo'
                organizationUrl = 'https://uwaterloo.ca/'
            }

            // For typetools
            developer {
                id = 'mernst'
                name = 'Michael Ernst'
                email = 'mernst@cs.washington.edu'
                url = 'https://homes.cs.washington.edu/~mernst/'
                organization = 'University of Washington'
                organizationUrl = 'https://www.cs.washington.edu/'
            }
            developer {
                id = 'smillst'
                name = 'Suzanne Millstein'
                email = 'smillst@cs.washington.edu'
                organization = 'University of Washington'
                organizationUrl = 'https://www.cs.washington.edu/'
            }
        }

        scm {
            url = 'https://github.com/eisop/checker-framework.git'
            connection = 'scm:git:https://github.com/eisop/checker-framework.git'
            developerConnection = 'scm:git:ssh://git@github.com/eisop/checker-framework.git'
        }
    }
}
tasks.register('printJavaVersion') {
    description = "Prints the Java version used to run Gradle."
    doLast {
        println "Java version used to run Gradle: ${System.getProperty('java.version')}"
        def currentJvm = org.gradle.internal.jvm.Jvm.current()
        println currentJvm
    }
}
